or_term                    = "or" / "OR" / "|OR|"
var_name                   = 1*CHAR [ 1*(CHAR/ALPHA/_) ]
var_name_access            = "%" var_name
dotted_access              = "." (var_name / var_name_access / "*")
property_access            = var_name [ dotted_access ]
variable_access            = var_name_access [ dotted_access ]
access                     = variable_access / property_access
not_keyword                = "NOT" / "not" / "!"
basic_cmp                  = "==" / ">=" / "<=" / ">" / "<"
other_operators            = "IN" / "EXISTS" / "EMPTY"
not_other_operators        = not_keyword 1*SP other_operators
not_cmp                    = "!=" / not_other_operators / "NOT_IN"
special_operators          = "KEYS" 1*SP ("==" / other_operators / not_other_operators)
cmp                        = basic_cmp / other_operators / not_cmp / special_operators
clause                     = access 1*(LWSP/comment) cmp 1*(LWSP/comment) [(access/value)]
rule_clause                = rule_name / not_keyword rule_name / clause
rule_disjunction_clauses   = rule_clause 1*(or_term 1*(LWSP/comment) rule_clause)
rule_conjunction_clauses   = rule_clause 1*( (LSWP/comment) rule_clause )
type_clause                = type_name 1*SP clause
type_block                 = type_name *SP [when] "{" *(LWSP/comment) 1*clause "}"
type_expr                  = type_clause / type_block
disjunctions_type_expr     = type_expr 1*(or_term 1*(LWSP/comment) type_expr)
primitives                 = string / integer / float / regex
list_type                  = "[" *(LWSP/comment) *value *(LWSP/comment) "]"
map_type                   = "{" key_part *(LWSP/comment) ":" *(LWSP/comment) value *(LWSP/comment) "}"
key_part                   = string / var_name
value                      = primitives / map_type / list_type
comment                    =  "#" *CHAR (LF/CR)
assignment                 = "let" one_or_more_ws  var_name zero_or_more_ws ("=" / ":=") zero_or_more_ws (access/value)
when_type                  = when 1*( (LWSP/comment) clause (LWSP/comment) )
when_rule                  = when 1*( (LWSP/comment) rule_clause (LWSP/comment) )
named_rule                 = "rule" 1*SP var_name "{" assignment 1*(LWPS/comment)   / (type_expr 1*(LWPS/comment))  / (disjunctions_type_expr) *(LWSP/comment) "}"
expressions                = 1*( (assignment / named_rule / type_expr / disjunctions_type_expr / comment) (LWPS/comment) )
simple_unary               = "EXISTS" / "EMPTY"
keys_unary                 = "KEYS" 1*SP simple_unary
keys_not_unary             = "KEYS" 1*SP not_keyword 1*SP unary_operators
unary_operators            = simple_unary / keys_unary / not_keyword simple_unary / keys_not_unary
clause                     = access 1*SP unary_operators *(LWSP/comment) custom_message / access 1*SP binary_operators 1*(LWSP/comment) (access/value) *(LWSP/comment) custom_message
rule_clause                = (var_name (LWSP/comment)) / (var_name [1*SP << anychar >>] (LWSP/comment)
regex                      = "/" <any char not / or escaped by \/> "/"
string                     = DQUOTE <any char not DQUOTE> DQUOTE / "'" <any char not '> "'"
